---
layout: default
title: 2-4
nav_order: 4
parent: 习题 二
---

## 习题 -> 2.4&ensp;优先队列
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## 练习

### 1. 最大元素的返回字符

```
R R P O T Y I I U Q E U
```

### 2. 分析

因为在移除了最大元素之后需要更新最大值，显然时间复杂度是线性的。

### 3. 实现优先队列

见代码 <a href="https://algs4.cs.princeton.edu/24pq/OrderedArrayMaxPQ.java.html" target="_blank">OrderedArrayMaxPQ.java</a> ，<a href="https://algs4.cs.princeton.edu/24pq/UnorderedArrayMaxPQ.java.html" target="_blank">UnorderedArrayMaxPQ.java</a> 。

### 4. 降序排列的数组

是一个面向最大元素的堆。可以对应堆中的每一个值，且排列顺序无误，满足 *父节点 > 子结点* 。

### 5. 插入堆中的结果

```
Y T U S Q N E A S I O E
```

### 6. 每次操作后堆的内容

空行代表堆中没有元素（利用二叉堆）。

```
P
R P
R P I
R P I O
P O I
R P I O
P O I
O I
O I I
I I
T I I
I I
Y I I
I I
I

Q
U Q
U Q E
Q E
E

U

E

```

### 7. 第 k 大元素

大小为 31 的（二叉）堆可以看作一个深度为 5 的满二叉树。

- 当 \\(k=2\\) 时，也就是堆中的第二大元素，位置可能在 2 或 3 上；

- 当 \\(k=3\\) 时，也就是堆中的第三大元素，位置可能在 2、3、4、5、6 或 7 上；

- 当 \\(k=4\\) 时，也就是堆中的第四大元素，位置可能在 2、3、4、5、6、7、8、9、10、11、12、13、14 或 15 上。

其余位置不可能出现。

### 8. 第 k 小元素

- 当 \\(k=2\\) 时，也就是堆中的第二小元素，因为它不可能拥有两个子结点，所以位置只可能在 16、17、18、19、20、21、22、23、24、25、26、27、28、29、30 或 31 上；

- 当 \\(k=3\\) 时，也就是堆中的第三小元素，存在它和它的两个子结点是最小三个元素的情况，此时位置可能在 8、9、10、11、12、13、14、15、16、17、18、19、20、21、22、23、24、25、26、27、28、29、30 或 31 上；

- 当 \\(k=4\\) 时，也就是堆中的第四小元素，这就与 \\(k=3\\) 时的可能情况相同，因为它不可能同时具有两个子结点数目为 2 的子结点。

### 9. 可能构造出的堆

因为题目没有要求构造面向最大元素的堆，根据排列与组合的知识，共有 \\(A_5^{5}\\) 种可能的情况，这里就不一一列举出来了。

❓❓好像哪里不对，应该是要面向最大元素的吧 😅，那我们就按最大元素做吧！
{: .fs-2 }

- 对于 A B C D E
```
E C D A B
E C D B A
E D A B C
E D A C B
E D B A C
E D B C A
E D C A B
E D C B A
```

- 对于 A A A B B
```
B A B A A
B B A A A
```

### 10. 父节点和子结点在哪里 ？

数组的索引从 0 开始，但将索引值都加 1 不影响父节点和子结点的对应关系。所以我们可以得到：

- \\(k+1\\) 元素对应的父节点索引为 \\((k+1)/2\\) ，推出 \\(k\\) 元素对应的父节点索引为 \\((k+1)/2-1\\) ；
- \\(k+1\\) 元素对应的子结点索引为 \\(2(k+1)\\) 和 \\(2(k+1)+1\\) ，推出 \\(k\\) 元素对应的子节点索引为 \\(2k+1\\) 和 \\(2k+2\\) 。

### 11. 哪种更有效

无序数组。删除操作较少，主要考虑插入元素的成本，在常数时间内。

### 12. 哪种更有效

有序数组。插入和删除操作少，主要考虑最大元素寻找的成本，可以在常数时间内找到最大元素。

### 13. 避免检查 j < N

记不记得 `sink()` 方法 while 循环中有一行代码是

```java
if (j < N && less(j, j+1)) j++;
```

我们在这里只需要把这行修改成

```java
if (less(j+1, j)) j--;
```

因为我们的索引是从 1 开始的，所以在 `j = 2*k` 代码执行过后再进行递减操作，不会使 j 的索引值小于 1 。

另外这样做的目的就是为了能与子结点中较大的那个元素进行交换。

### 14. 最少交换几个元素 ？

`delMax()` 方法就是将堆顶和堆底元素进行交换，再使堆顶元素下沉的操作。

如果对于一个大小为 1、2 或 3 的堆来说，可能只需要进行第一步交换即可。而对于大小为 \\(N\\) 的堆来说，进行 sink 的成本可能会增加一些。我们知道可以将二叉堆看作是一棵依次占位的二叉树，树的深度就是 \\(⎣log_2{N}⎦ + 1\\) ，但这对于极端情况并没有太大意义。

我们要清晰堆末尾的元素可以追溯到根结点的左子结点或者右子结点，而不论它能追溯到它们两个中的哪一个，都会出现一种极端的情况：堆尾的这个元素所能追溯到的根结点的子结点恰好小于根结点的另外一个子结点，并且堆尾元素大于这个根结点另外一个子结点的两个子结点。这样一来，在进行第一次交换之后只需要再进行一次堆尾元素同根结点另外一个子结点的交换即可。总共需要进行两次交换！

**大小为 15 的堆的一个例子**

```
Z Y X E F V W A B C D R S T U

// 在进行删除最大元素操作之后
Y U X E F V W A B C D R S T
```

如果一次没有明白那就多读几遍，上面的文字信息介绍得还是挺清晰的 😁。

删除两次需要进行 3 次交换，删除三次需要进行 4 次交换。这两种情况这里就不说了，与上面类似，相信你可以找到思路的！

### 15. 是否是一个面向最小元素的堆 ？

参考 <a href="https://algs4.cs.princeton.edu/24pq/MinPQ.java.html" target="_blank">MinPQ.java</a> 中的 `isMinHeap()` 方法。

### 16. 构造数组

比较次数最少的一种情况就是所有元素的键值都相等，这样一来也就不需要进行交换操作，每次方法的调用只进行一次比较。

有一篇论文讨论了堆排序最坏输入的构造方式，参见：<a href="https://arxiv.org/pdf/1504.01459.pdf" target="_blank">A Complete Worst-Case Analysis of Heapsort with...</a> 。

以及对应的 Java 代码：<a href="http://csc.csudh.edu/suchenek/MakeHeap.html" target="_blank">MakeHeap.java</a> 。

### 17. 证明

这道题书中翻译有误，英文原版是 *(insert followed by remove the minimum)* ，所以是先插入，再进行删除操作。

因为是面向最小元素的优先队列，先将新插入的元素同堆顶元素进行比较，如果小于堆顶元素直接删除；如果大于堆顶元素，删除堆顶元素，将它设置为堆顶元素，执行下沉操作（ `sink()` 方法）。

这组操作实现的就是删除了队列中的前 \\(N-k\\) 小元素，最终留下的就是前 \\(k\\) 大元素了。

### 18. 堆还相同吗 ？

在我们插入了一个比所有元素都要大的新元素时，它需要 `swim()` 到根结点的位置，在 `swim()` 途中与它进行交换的结点都移动到了自己子结点的位置。此时路径上的每个结点都要比它父结点的另一个子结点大，这也就保证了我们再进行首尾元素交换后的下沉操作是按原始交换路径返回的（同样是交换操作）。

所以现在的堆与操作之前的堆是相同的，你可以写几个例子来验证这一结论。而先后进行两次插入和删除操作与这种情况类似，这里就不多做解释了。

### 19. 实现构造函数

官方已经实现了这一部分的代码，见 <a href="https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html" target="_blank">MaxPQ.java</a> 。

对应的构造函数在这里：

```java
public MaxPQ(Key[] keys) {
    n = keys.length;
    pq = (Key[]) new Object[keys.length + 1];
    for (int i = 0; i < n; i++)
        pq[i+1] = keys[i];
    for (int k = n/2; k >= 1; k--)
        sink(k);
    assert isMaxHeap();
}
```

### 20. 证明

官网上给出了证明过程，见 <a href="https://algs4.cs.princeton.edu/24pq/" target="_blank">2.4 Priority Queues</a> 。

---

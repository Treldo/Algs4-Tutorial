符号表最主要的目的就是将一个<mark>键</mark>和一个<mark>值</mark>联系起来。本章会讲解多种构造这种数据结构的方法，它们不仅能够高效地插入和查找，还可以进行其他几种方便的操作。

<!-- tabs:start -->

#### **<b>定义</b>**

符号表是一种储存键值对的数据结构，支持两种操作：**插入（put）**，即将一组新的键值对存入表中；**查找（get）**，即根据给定的键得到对应的值。

<!-- tabs:end -->

**典型应用：**字典，图书索引，文件共享，账户管理，网络搜索，编译器...

## API

**一种简单泛型符号表 API**

![api](../_media/3.1/table-api.jpeg ':size=600')

### 设计决策

- **泛型：**没有指定处理对象的类型。
- **重复的键：**
    + 每个键只对应一个值；
    + 新的键值对会在产生冲突时覆盖旧的键值对。
- **空键：**键不能为空，否则会产生运行时异常。
- **空值：**不允许有空值，否则会与 `get()` 方法返回值混淆。
- **删除操作：**
    + *延时删除：*将键值设置为空，在某个时候删去所有键值为空的键。
    + *即时删除：*立即删除指定的键。
- **便捷方法：**

<div style="text-align: center;">

![table-methods](../_media/3.1/table-methods.jpeg ':size=450')

</div>

- **迭代：**使用迭代器以方便遍历所有的键。
- **键的等价性：**为自己的数据类型实现 `equals()` 方法。

## 有序符号表

**一种有序的泛型符号表的 API**

![signed-api](../_media/3.1/symbol-table-api.jpeg ':size=600')

### 设计决策

- **最大键和最小键：**相对于优先队列，有序符号表支持的操作更多，但不可以存在重复的键。
- **向上取整和向下取整：**表示找出大于等于或小于等于该键的最小键或最大键。
- **排名和选择：**即找出小于等于指定键的键的数量，以及找出排名为 k 的键。
- **范围查找：**给定范围内键的数量是多少？有哪些？这就需要接受两个参数的 `size()` 和 `key()` 方法。
- **例外情况：**当一个方法需要返回一个键，但没有合适的键可以反回时，我们会抛出一个异常。
- **便捷方法：**

<div style="text-align: center;">

![symbol-table-methods](../_media/3.1/symbol-table-methods.jpeg ':size=600')

</div>

- **（再谈）键的等价性：**任何一种 Compareable 类型的两个值 a 和 b 都要保证 `a.compareTo(b) == 0` 和 `a.equals(b)` 的返回值相同。为避免潜在的二义性，我们只使用 `compareTo()` 方法来比较两个键。
- **成本模型：**我们使用<mark>比较</mark>一词来表示将一个符号表条目和一个被查找的键进行比较的操作。

<!-- tabs:start -->

#### **<b>查找的成本模型</b>**

在符号表的实现中，我们会统计<mark>比较</mark>的次数（等价性测试或是键的相互比较）。在内循环不进行比较（极少）的情况下，我们会统计 **数组的访问次数** 。

<!-- tabs:end -->

符号表的重点在于其中使用的数据结构和 `get()`、`put()` 方法。在用例代码中，除非我们想使用一个特定的实现，我们都会使用 ST 表示一个符号表的实现。

## 用例举例